![run-tests](../../workflows/run-tests/badge.svg)

## Δομές Δεδομένων και Τεχνικές Προγραμματισμού

### Κώδικας Εργαστηρίου 5

Εκφώνηση: https://k08.chatzi.org/labs/lab5/

Worst-case πολυπλοκότητες:<br>
Στην αρχική κοινή υλοποίηση (commented out):<br>
Binary Search Tree: O(n^2)<br>
Στην χειρότερη περίπτωση το δέντρο είναι λίστα. Η set_first διασχίζει την λίστα, άρα είναι O(h) = Ο(n). Για κάθε set_next πρέπει να βρεθεί ο τρέχων κόμβος, άρα διασχιστεί η λίστα, με πολυπλοκότητα O(h) = O(n), και αυτό γίνεται n φορές.<br>
AVL: O(nlogn)<br>
Η set_first διασχίζει το δέντρο, άρα είναι Ο(h) = O(logn). Για κάθε set_next πρέπει να βρεθεί ο τρέχων κόμβος, με πολυπλοκότητα O(h) = O(logn), και αυτό γίνεται n φορές.<br>
BTree: O(n)<br>
Η set_first είναι Ο(logn). Εφόσον υπάρχει πρόσβαση προς τους πατέρες, η set_next είναι κατά μέσο όρο σταθερή, άρα συνολικά η πολυπλοκότητα είναι Ο(n). (παρομοίως με την efficient heapify του σωρού)<br>
Στις πιο αποδοτικές υλοποιήσεις:<br>
Binary Search Tree: O(n)<br>
Η συνάρτηση node_visit καλείται μια φορά για κάθε κόμβο και είναι κατά τα άλλα σταθερή.<br>
AVL: O(n)<br>
Η συνάρτηση node_visit καλείται μια φορά για κάθε κόμβο και είναι κατά τα άλλα σταθερή.<br>
BTree: O(n)<br>
Η συνάρτηση node_visit καλείται μια φορά για κάθε κόμβο και είναι κατά τα άλλα σταθερή. (Το count που είναι το όριο της επανάληψης είναι φραγμένο από το MAX_VALUES ου είναι ανεξάρτητο του n)<br>
Μετρήσεις του χρόνου της set_visit με clock για set με 50 000 προστεθημένα σε αύξουσα σειρά:<br>
Στην αρχική κοινή υλοποίηση (commented out):<br>
Binary Search Tree: 16.575668<br>
AVL:                 0.009568 secs<br>
BTree:               0.001998 secs<br>
Στις πιο αποδοτικές υλοποιήσεις:<br>
Binary Search Tree:  0.001290 secs<br>
AVL:                 0.001665<br>
BTree:               0.001112 secs<br>